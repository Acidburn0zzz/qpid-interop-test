diff --git lib/types.js lib/types.js
index 985607f..f1d5514 100644
--- lib/types.js
+++ lib/types.js
@@ -270,6 +270,12 @@ function is_one_of(o, typelist) {
     }
     return false;
 }
+function buffer_zero(b, len, neg) {
+    for (var i = 0; i < len && i < b.length; i++) {
+        if (b[i] !== (neg ? 0xff : 0)) return false;
+    }
+    return true;
+}
 types.is_ulong = function(o) {
     return is_one_of(o, [types.Ulong, types.Ulong0, types.SmallUlong]);
 };
@@ -290,8 +296,13 @@ types.wrap_boolean = function(v) {
     return v ? new types.True() : new types.False();
 };
 types.wrap_ulong = function(l) {
-    if (l === 0) return new types.Ulong0();
-    else return l > 255 ? new types.Ulong(l) : new types.SmallUlong(l);
+    if (Buffer.isBuffer(l)) {
+        if (buffer_zero(l, 8, false)) return new types.Ulong0();
+        return buffer_zero(l, 7, false) ? new types.SmallUlong(l[7]) : new types.Ulong(l);
+    } else {
+        if (l === 0) return new types.Ulong0();
+        else return l > 255 ? new types.Ulong(l) : new types.SmallUlong(l);
+    }
 };
 types.wrap_uint = function(l) {
     if (l === 0) return new types.Uint0();
@@ -304,7 +315,15 @@ types.wrap_ubyte = function(l) {
     return new types.Ubyte(l);
 };
 types.wrap_long = function(l) {
-    return l > 127 || l < -128 ? new types.Long(l) : new types.SmallLong(l);
+    if (Buffer.isBuffer(l)) {
+        var negFlag = (l[0] & 0x80) !== 0;
+        if (buffer_zero(l, 7, negFlag) && (l[7] & 0x80) === (negFlag ? 0x80 : 0)) {
+            return new types.SmallLong(negFlag ? -((l[7] ^ 0xff) + 1) : l[7]);
+        }
+        return new types.Long(l);
+    } else {
+        return l > 127 || l < -128 ? new types.Long(l) : new types.SmallLong(l);
+    }
 };
 types.wrap_int = function(l) {
     return l > 127 || l < -128 ? new types.Int(l) : new types.SmallInt(l);
